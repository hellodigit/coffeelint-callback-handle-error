// Generated by CoffeeScript 1.10.0
(function() {
  var CallbackHandleError, getNodeType, isErrorVariable;

  getNodeType = function(node) {
    return node.constructor.name;
  };

  isErrorVariable = function(var_name) {
    var regex;
    regex = /(^err(or)?$)|(_err(or)?$)|(^err(or)?_)/i;
    return regex.test(var_name);
  };

  module.exports = CallbackHandleError = (function() {
    function CallbackHandleError() {}

    CallbackHandleError.prototype.rule = {
      name: 'callback_handle_error',
      level: 'error',
      message: 'Error in callback not handled',
      description: 'Finds instances of error objects passed through a callback not being handled'
    };

    CallbackHandleError.prototype.lintAST = function(node, astApi) {
      this.astApi = astApi;
      this.lintNode(node);
    };

    CallbackHandleError.prototype.lintNode = function(node) {
      var i, len, node_type, param, ref, ref1, var_name;
      node_type = getNodeType(node);
      switch (node_type) {
        case 'Code':
          ref = node.params;
          for (i = 0, len = ref.length; i < len; i++) {
            param = ref[i];
            var_name = (ref1 = param.name) != null ? ref1.value : void 0;
            if (isErrorVariable(var_name)) {
              if (!this.handlesError(node, var_name)) {
                this.throwError(node, "Error object '" + var_name + "' in callback not handled");
              }
            }
          }
      }
      node.eachChild((function(_this) {
        return function(child) {
          _this.lintNode(child);
        };
      })(this));
    };

    CallbackHandleError.prototype.handlesError = function(code_node, var_name) {
      var found_usage;
      found_usage = false;
      code_node.traverseChildren(true, function(child) {
        var arg, i, inner_child_type, j, len, len1, node_type, param, ref, ref1;
        node_type = getNodeType(child);
        switch (node_type) {
          case 'If':
            child.condition.traverseChildren(false, function(inner_child) {
              var inner_type;
              inner_type = getNodeType(inner_child);
              switch (inner_type) {
                case 'Literal':
                case 'IdentifierLiteral':
                  if (inner_child.value === var_name) {
                    found_usage = true;
                    return false;
                  }
              }
            });
            break;
          case 'Call':
            ref = child.args;
            for (i = 0, len = ref.length; i < len; i++) {
              arg = ref[i];
              arg.traverseChildren(false, function(inner_child) {
                var inner_type;
                inner_type = getNodeType(inner_child);
                switch (inner_type) {
                  case 'Literal':
                  case 'IdentifierLiteral':
                    if (inner_child.value === var_name) {
                      found_usage = true;
                      return false;
                    }
                }
              });
            }
            return;
          case 'Code':
            ref1 = child.params;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              param = ref1[j];
              inner_child_type = getNodeType(param);
              if (inner_child_type === 'Param') {
                if (param.name.value === var_name) {
                  return false;
                }
              }
            }
        }
        if (found_usage) {
          return false;
        }
      });
      return found_usage;
    };

    CallbackHandleError.prototype.throwError = function(node, message) {
      var err;
      err = this.astApi.createError({
        lineNumber: node.locationData.first_line + 1,
        message: message
      });
      this.errors.push(err);
    };

    return CallbackHandleError;

  })();

}).call(this);

//# sourceMappingURL=index.js.map
