// Generated by CoffeeScript 1.10.0
(function() {
  var CallbackHandleError, ERROR_TYPES, getNodeType,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  getNodeType = function(node) {
    return node.constructor.name;
  };

  ERROR_TYPES = {
    NO_ERROR: "NO_ERROR",
    DEFAULT: "DEFAULT",
    DESTRUCT_DEFAULT_REQUIRED: "DESTRUCT_DEFAULT_REQUIRED"
  };

  module.exports = CallbackHandleError = (function() {
    function CallbackHandleError() {}

    CallbackHandleError.prototype.rule = {
      name: 'callback_handle_error',
      level: 'error',
      message: 'Error in callback not handled',
      description: 'Finds instances of error objects passed through a callback not being handled',
      patterns: ["^err(or)?", "[Ee]rr(or)?$"]
    };

    CallbackHandleError.prototype.lintAST = function(node, astApi) {
      var pattern, patterns, ref;
      this.astApi = astApi;
      patterns = (ref = this.astApi.config.patterns) != null ? ref : this.rule.patterns;
      this.errorVariablePatterns = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = patterns.length; i < len; i++) {
          pattern = patterns[i];
          results.push(new RegExp(pattern));
        }
        return results;
      })();
      this.lintNode(node);
    };

    CallbackHandleError.prototype.lintNode = function(node) {
      var error_type, i, j, len, len1, node_type, param, pattern, ref, ref1, ref2, var_name;
      node_type = getNodeType(node);
      switch (node_type) {
        case 'Code':
          ref = node.params;
          for (i = 0, len = ref.length; i < len; i++) {
            param = ref[i];
            var_name = (ref1 = param.name) != null ? ref1.value : void 0;
            ref2 = this.errorVariablePatterns;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              pattern = ref2[j];
              if (pattern.test(var_name)) {
                error_type = this.handlesError(node, var_name);
                switch (error_type) {
                  case ERROR_TYPES.NO_ERROR:
                    (function() {})();
                    break;
                  case ERROR_TYPES.DESTRUCT_DEFAULT_REQUIRED:
                    this.throwError(node, "Default must be specified when destructuring an array or object in a callback parameter");
                    break;
                  case ERROR_TYPES.DEFAULT:
                    this.throwError(node, "Error object '" + var_name + "' in callback not handled");
                    break;
                  default:
                    this.throwError(node, "An unknown error occurred for '" + var_name + "'");
                }
                break;
              }
            }
          }
      }
      node.eachChild((function(_this) {
        return function(child) {
          _this.lintNode(child);
        };
      })(this));
    };

    CallbackHandleError.prototype.handlesError = function(code_node, var_name) {
      var error_type, found_usage, non_usages, obj_idents, obj_idents_pending;
      obj_idents_pending = [];
      obj_idents = [];
      non_usages = [];
      error_type = null;
      found_usage = false;
      code_node.traverseChildren(true, function(child) {
        var arg, found_non_usage, function_name, i, inner_child_type, j, k, len, len1, len2, nameType, node_type, obj, param, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, valueType;
        node_type = getNodeType(child);
        switch (node_type) {
          case 'If':
            found_non_usage = non_usages.length > 0;
            child.condition.traverseChildren(false, function(inner_child) {
              var inner_type;
              inner_type = getNodeType(inner_child);
              switch (inner_type) {
                case 'Literal':
                case 'IdentifierLiteral':
                  if (inner_child.value === var_name) {
                    if (!found_non_usage) {
                      found_usage = true;
                      return false;
                    }
                  }
              }
            });
            break;
          case 'Call':
            function_name = (ref = child.variable) != null ? (ref1 = ref.base) != null ? ref1.value : void 0 : void 0;
            found_non_usage = non_usages.some(function(a) {
              return a !== function_name;
            });
            ref2 = child.args;
            for (i = 0, len = ref2.length; i < len; i++) {
              arg = ref2[i];
              arg.traverseChildren(false, function(inner_child) {
                var inner_type;
                inner_type = getNodeType(inner_child);
                switch (inner_type) {
                  case 'Literal':
                  case 'IdentifierLiteral':
                    if (inner_child.value === var_name) {
                      if (!found_non_usage) {
                        found_usage = true;
                        return false;
                      }
                    }
                }
              });
            }
            return;
          case 'Code':
            ref3 = child.params;
            for (j = 0, len1 = ref3.length; j < len1; j++) {
              param = ref3[j];
              inner_child_type = getNodeType(param);
              if (inner_child_type === 'Param') {
                if (param.name.value === var_name) {
                  return false;
                }
              }
            }
            break;
          case 'Value':
            if (!(ref4 = (ref5 = child.base) != null ? ref5.value : void 0, indexOf.call([void 0, var_name, 'this'].concat(obj_idents), ref4) >= 0)) {
              non_usages.push((ref6 = child.base) != null ? ref6.value : void 0);
              return true;
            }
            break;
          case 'Param':
            nameType = getNodeType(child.name);
            if (nameType === 'Arr' || nameType === 'Obj') {
              obj_idents_pending = [];
              ref7 = child.name.objects;
              for (k = 0, len2 = ref7.length; k < len2; k++) {
                obj = ref7[k];
                inner_child_type = getNodeType(obj);
                if (inner_child_type === 'Value') {
                  obj_idents_pending.push(obj.base.value);
                }
              }
              if ((ref8 = child.value) != null ? ref8.base : void 0) {
                valueType = getNodeType(child.value.base);
                if (valueType === nameType) {
                  if (!child.value.base.objects.length) {
                    obj_idents = obj_idents.concat(obj_idents_pending);
                    obj_idents_pending = [];
                  }
                }
              }
              if (obj_idents_pending.length) {
                error_type = ERROR_TYPES.DESTRUCT_DEFAULT_REQUIRED;
              }
            }
        }
        if (error_type || found_usage) {
          return false;
        }
      });
      if (error_type) {
        return error_type;
      } else if (found_usage) {
        return ERROR_TYPES.NO_ERROR;
      } else {
        return ERROR_TYPES.DEFAULT;
      }
    };

    CallbackHandleError.prototype.throwError = function(node, message) {
      var err;
      err = this.astApi.createError({
        lineNumber: node.locationData.first_line + 1,
        message: message
      });
      this.errors.push(err);
    };

    return CallbackHandleError;

  })();

}).call(this);
